/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * APTLexer is  an  Antlr-4  version of  the  old cnd.apt  
 * "aptlexer.g" written in Antlr 2.
 *
 * References:
 * - Antlr4 Lexer Rules https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md
 * - Antlr4 Predicates in Lexer Rules: https://github.com/antlr/antlr4/blob/master/doc/predicates.md#predicates-in-lexer-rules
 */

lexer grammar APTLexer;

// Some channels used to send tokens we're not interested in
channels {COMMENT}

options {
    language = Java;
}


@lexer::header {
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/* This file was automatically generated by Antlr4 from APTLexer.g4. */

}

@lexer::members {
    public static enum LanguageMode {
        C_CPP,
        FORTRAN
    };
    private LanguageMode languageMode = LanguageMode.C_CPP;
}

// ----------------------------------------------------------------------
// DEFAULT_MODE
// This is the mode that the lexer runs by default.
// - In this mode we recognize:
//   - C/C++/Objective-C strings
//   - C/C++ block comments and comments (in C/C++ mode).
//   - Fortran comments (in Fortran mode).
//   - Some punctuation tokens (';', '/', '/=' ,etc.)
//   - C preprocessor directives (using antlr4 'lexical modes').
//   - We do _not_ recognize language specific operators/keywords.
// - Additional posterior lexers/filters are responsible for language
//   specific keyword/operator recognition.
// ----------------------------------------------------------------------

FORTRAN_COMMENT:
    { languageMode == LanguageMode.FORTRAN }?
    '!' ~[\r\n]* -> channel(COMMENT);

FORTRAN_77_COMMENT:
    { languageMode == LanguageMode.FORTRAN && getCharPositionInLine() == 0}?
    [cC*] ~[\r\n]* -> channel(COMMENT);

LINE_COMMENT:
    { languageMode == LanguageMode.C_CPP }?
    '//' ~[\r\n]* -> channel(COMMENT);

BLOCK_COMMENT:
    { languageMode == LanguageMode.C_CPP }?
    '/*' .*? '*/' -> channel(COMMENT);

fragment STRING_ENCODING:
    'u8' | 'u' | 'U' | 'L' | '@';

// See https://docs.microsoft.com/en-us/cpp/c-language/octal-and-hexadecimal-character-specifications?view=msvc-160
fragment OCTAL_DIGIT:
    (
        [0-7]
        | [1-7][0-7]
        | [1-7][0-7][0-7]
    );

fragment HEXADECIMAL_DIGIT:
    (
        [0-9A-Fa-f]
        | [0-9A-Fa-f] [0-9A-Fa-f]
        | [0-9A-Fa-f] [0-9A-Fa-f] [0-9A-Fa-f]
    );

// Characters allowed in a non-raw string
// https://docs.microsoft.com/en-us/cpp/c-language/c-character-constants?view=msvc-160
fragment STRING_CHAR:
    (
        '\\' ('\r\n' | '\n') // Continuation line
        | '\\x' HEXADECIMAL_DIGIT
        | '\\' ['!?abfnrtv\\] // Character escape sequences (\r \a)
        | '\\' OCTAL_DIGIT
        | ~[\n\r"\\]
    );

        
STRING_LITERAL:
    STRING_ENCODING?
    (
        '"' STRING_CHAR* '"'
    );

// Characters

fragment CHAR_ENCODING:
    'u' | 'U' | 'L';

fragment CHAR_CONTENT:
    (
        '\\' ('\r\n' | '\n') // Continuation line
        | '\\x' HEXADECIMAL_DIGIT
        | '\\' ['!?abfnrtv\\] // Character escape sequences (\r \a)
        | '\\' OCTAL_DIGIT
        | ~[\n\r\\]
    );

CHAR_LITERAL:
    CHAR_ENCODING?  '\'' CHAR_CONTENT '\'' ;

// Numbers

fragment SIGN:
    [+-];

fragment DECIMAL:
    [0-9] [0-9]*;

LONG:
    SIGN? DECIMAL 'lL';

INTEGER:
    SIGN? DECIMAL;

HEXADECIMAL:
    SIGN? '0' [xX] [0-9a-fA-F]+;

REAL:
    DECIMAL '.' ([eE] SIGN? DECIMAL)?;

// #include "... and %:+ include "...
INCLUDE_LOCAL:
    ('#' | '%:'+)
    [ \t]*
    'include'
    [ \t]*
    '"' -> mode(READ_INCLUDE_LOCAL_FILENAME);

// #include "... and %:+ include "...
INCLUDE_SYSTEM:
    ('#' | '%:'+)
    [ \t]*
    'include'
    [ \t]*
    '<' -> mode(READ_INCLUDE_SYSTEM_FILENAME);

// #define "... and %:+ include "...
DEFINE:
    ('#' | '%:'+)
    [ \t]*
    'define'
    [ \t]* -> mode(READ_DEFINE_NAME_MACRO_MODE);

IFDEF:
    ('#' | '%:'+)
    [ \t]*
    'ifdef'
    [ \t]* -> mode(READ_DEFINE_NAME_REF_MODE);

UNDEF:
    ('#' | '%:'+)
    [ \t]*
    'undef'
    [ \t]* -> mode(READ_DEFINE_NAME_REF_MODE);

IF:
    ('#' | '%:'+)
    [ \t]*
    'if'
    [ \t]* -> mode(PREPROC_EXPRESSION_MODE);

ELSE:
    ('#' | '%:'+)
    [ \t]*
    'else'
    [ \t]*;

ENDIF:
    ('#' | '%:'+)
    [ \t]*
    'endif'
    [ \t]*;

// TODO: Trigraphs?


HASH: '#';

// Digraphs
// https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C
DIGRAPH_LSQUARE         : '<:'  -> type(LSQUARE);
DIGRAPH_RSQUARE         : ':>'  -> type(RSQUARE);
DIGRAPH_LCURLY          : '<%'  -> type(LCURLY);
DIGRAPH_RCURLY          : '%>'  -> type(RCURLY);
DIGRAPH_HASH            : '%:'+ -> type(HASH);

// Operators and punctuation
COMMA                   : ',';
QUESTIONMARK            : '?';
SEMICOLON               : ';';
LPAREN                  : '(';
RPAREN                  : ')';
LSQUARE                 : '[';
RSQUARE                 : ']';
LCURLY                  : '{';
RCURLY                  : '}';
TILDE                   : '~';
EQUAL                   : '==';
ASSIGNEQUAL             : '=';
DIVIDEEQUAL             : '/=';
DIVIDE                  : '/';
TIMESEQUAL              : '*=';
STAR                    : '*';
MODEQUAL                : '%=';
MOD                     : '%';
NOTEQUAL                : '!=';
NOT                     : '!';
BITWISEANDEQUAL         : '&=';
AND                     : '&&';
AMPERSAND               : '&';
OR                      : '||';
BITWISEOREQUAL          : '|=';
BITWISEOR               : '|';
BITWISEXOREQUAL         : '^=';
BITWISEXOR              : '^';
SCOPE                   : '::';
COLON                   : ':';
SHIFTLEFT               : '<<';
LESSTHANOREQUALTO       : '<=';
LESSTHAN                : '<'; // TODO: Review this one <:: C++11 2.5p3 bullet 2???
AT                      : '@';
GRAVE_ACCENT            : '`';
SHIFTRIGHTEQUAL         : '>>=';
GREATERTHANOREQUALTO    : '>=';
GREATERTHAN             : '>';
POINTERTOMBR            : '->*';
POINTERTO               : '->';
MINUSMINUS              : '--';
MINUSEQUAL              : '-=';
MINUS                   : '-';
PLUSPLUS                : '++';
PLUSEQUAL               : '+=';
PLUS                    : '+';

// Identifiers
// https://docs.microsoft.com/en-us/cpp/c-language/c-identifiers?view=msvc-160

IDENTIFIER:
    [a-zA-Z_] [a-zA-Z0-9_]*;

SPACES:
    [ \t\r\n]+ -> skip;

// ----------------------------------------------------------------------
// READ_INCLUDE_LOCAL_FILENAME
// We enter this mode after '#include "'
// (or equivalent)
// ----------------------------------------------------------------------

mode READ_INCLUDE_LOCAL_FILENAME;

INCLUDE_LOCAL_FILENAME:
    ~[\r\n]+ '"' -> mode(DEFAULT_MODE);

// ----------------------------------------------------------------------
// READ_INCLUDE_SYSTEM_FILENAME
// We enter this mode after '#include <'
// (or equivalent)
// ----------------------------------------------------------------------

mode READ_INCLUDE_SYSTEM_FILENAME;

INCLUDE_SYSTEM_FILENAME:
    ~[\r\n]+ '>' -> mode(DEFAULT_MODE);

// ----------------------------------------------------------------------
// READ_DEFINE_NAME_MACRO_MODE
// We enter this mode after '#define '
// (or equivalent)
// ----------------------------------------------------------------------
mode READ_DEFINE_NAME_MACRO_MODE;

DEFINE_IDENTIFIER:
    [a-zA-Z_] [a-zA-Z0-9_]* [ \t]* -> mode(READ_MACRO_ARGS_OR_EXPRESSION_MODE);

// ----------------------------------------------------------------------
// READ_DEFINE_NAME_REF_MODE
// We enter this mode after '#define '
// (or equivalent)
// ----------------------------------------------------------------------
mode READ_DEFINE_NAME_REF_MODE;

DEFINE_NAME_REF:
    [a-zA-Z_] [a-zA-Z0-9_]* [ \t]* -> mode(READ_MACRO_ARGS_OR_EXPRESSION_MODE);

// ----------------------------------------------------------------------
// READ_MACRO_ARGS_OR_EXPRESSION_MODE
// We enter this mode after '#define XXXX'
// ----------------------------------------------------------------------
mode READ_MACRO_ARGS_OR_EXPRESSION_MODE;

fragment ARGUMENT_IDENTIFIER:
    [ \t]* [a-zA-Z_] [a-zA-Z0-9_]* [ \t]*;

DEFINE_MACRO_ARGUMENTS:
    [ \t]*
    '('
        ARGUMENT_IDENTIFIER
        ( ',' ARGUMENT_IDENTIFIER )*
    ')' -> mode(PREPROC_EXPRESSION_MODE);

DEFINE_ID:
    [ \t\r\n] -> mode(DEFAULT_MODE);

DEFINE_EXPRESSION:
    [ \t]*
    ~'('
    (
        '\\\n'
        | '\\\r\n'
        | ~[\r\n]
    )+ -> mode(DEFAULT_MODE);

// ----------------------------------------------------------------------
// PREPROC_EXPRESSION_MODE
// We enter this mode to read a preprocessor expression.
// This can be a constant or an expression or something.
// ----------------------------------------------------------------------
mode PREPROC_EXPRESSION_MODE;

DEFINE_VALUE:
    (
        '\\\n'
        | '\\\r\n'
        | ~[\r\n]
    )+ -> mode(DEFAULT_MODE);

