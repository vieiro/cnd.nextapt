/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * APTLexer is  an  Antlr-4  version of  the  old cnd.apt  
 * "aptlexer.g" written in Antlr 2.
 *
 * References:
 * - Antlr4 Lexer Rules https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md
 * - Antlr4 Predicates in Lexer Rules: https://github.com/antlr/antlr4/blob/master/doc/predicates.md#predicates-in-lexer-rules
 */

lexer grammar APTLexer;

// Some channels used to send tokens we're not interested in
channels {COMMENT}

options {
    language = Java;
}


@lexer::header {
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/* This file was automatically generated by Antlr4 from APTLexer.g4. */

}

@lexer::members {
    public static enum LanguageMode {
        C_CPP,
        FORTRAN
    };
    private LanguageMode languageMode = LanguageMode.C_CPP;

    /*
     * A flag that indicates that we're reading a preprocessor expression in DEFAULT_MODE.
     * This means that:
     * - A '\' followed that \n or \r\n must be ignored.
     * - A \n or a \r\n must emit PREPROC_SUBMODE_END token.
     */
    protected boolean isPreprocExpressionSubmode = false;

    protected void enterPreprocExpressionSubmode() {
        isPreprocExpressionSubmode = true;
        mode(DEFAULT_MODE);
    }

    protected void leavePreprocExpressionSubmode() {
        isPreprocExpressionSubmode = false;
        mode(DEFAULT_MODE);
    }
}

// ----------------------------------------------------------------------
// DEFAULT_MODE
// This is the mode that the lexer runs by default.
// - In this mode we recognize:
//   - C/C++/Objective-C strings
//   - C/C++ block comments and comments (in C/C++ mode).
//   - Fortran comments (in Fortran mode).
//   - Some punctuation tokens (';', '/', '/=' ,etc.)
//   - C preprocessor directives (using antlr4 'lexical modes').
//   - We do _not_ recognize language specific operators/keywords.
// - Additional posterior lexers/filters are responsible for language
//   specific keyword/operator recognition.
// ----------------------------------------------------------------------

FORTRAN_COMMENT:
    { languageMode == LanguageMode.FORTRAN }?
    '!' ~[\r\n]* -> channel(COMMENT);

FORTRAN_77_COMMENT:
    { languageMode == LanguageMode.FORTRAN && getCharPositionInLine() == 0}?
    [cC*] ~[\r\n]* -> channel(COMMENT);

LINE_COMMENT:
    { languageMode == LanguageMode.C_CPP }?
    '//' ~[\r\n]* -> channel(COMMENT);

BLOCK_COMMENT:
    { languageMode == LanguageMode.C_CPP }?
    '/*' .*? '*/' -> channel(COMMENT);

fragment STRING_ENCODING:
    'u8' | 'u' | 'U' | 'L' | '@';

// See https://docs.microsoft.com/en-us/cpp/c-language/octal-and-hexadecimal-character-specifications?view=msvc-160
fragment OCTAL_DIGIT:
    (
        [0-7]
        | [1-7][0-7]
        | [1-7][0-7][0-7]
    );

fragment HEXADECIMAL_DIGIT:
    (
        [0-9A-Fa-f]
        | [0-9A-Fa-f] [0-9A-Fa-f]
        | [0-9A-Fa-f] [0-9A-Fa-f] [0-9A-Fa-f]
    );

// Characters allowed in a non-raw string
// https://docs.microsoft.com/en-us/cpp/c-language/c-character-constants?view=msvc-160
fragment STRING_CHAR:
    (
        '\\' ('\r\n' | '\n') // Continuation line
        | '\\x' HEXADECIMAL_DIGIT
        | '\\' ['!?abfnrtv\\] // Character escape sequences (\r \a)
        | '\\' OCTAL_DIGIT
        | ~[\n\r"\\]
    );

        
STRING_LITERAL:
    STRING_ENCODING?
    (
        '"' STRING_CHAR* '"'
    );

// Characters

fragment CHAR_ENCODING:
    'u' | 'U' | 'L';

fragment CHAR_CONTENT:
    (
        '\\' ('\r\n' | '\n') // Continuation line
        | '\\x' HEXADECIMAL_DIGIT
        | '\\' ['!?abfnrtv\\] // Character escape sequences (\r \a)
        | '\\' OCTAL_DIGIT
        | ~[\n\r\\]
    );

CHAR_LITERAL:
    CHAR_ENCODING?  '\'' CHAR_CONTENT '\'' ;

// Numbers

fragment DECIMAL:
    [0-9] [0-9]*;

ULONG:
    DECIMAL ('ull' | 'uLL' | 'Ull' | 'ULL' | 'llu' | 'LLu' | 'LLU')?;

LONG:
    DECIMAL ('ul' | 'uL' | 'Ul' | 'UL' | 'lu' | 'lU' | 'Lu' | 'LU')?;

INTEGER:
    DECIMAL;

HEXADECIMAL:
    '0' [xX] [0-9a-fA-F]+;

fragment SIGN:
    [+-];

REAL:
    DECIMAL '.' DECIMAL? ([eE] SIGN? DECIMAL)?;

// #include "... and %:+ include "...
INCLUDE:
    ('#' | '%:'+)
    [ \t]*
    'include'
    [ \t]*
    -> mode(READ_INCLUDE_MODE);

// #define "... and %:+ include "...
DEFINE:
    ('#' | '%:'+)
    [ \t]*
    'define'
    [ \t]* -> mode(READ_DEFINE_MODE);

IFDEF:
    ('#' | '%:'+)
    [ \t]*
    'ifdef'
    [ \t]* -> mode(READ_DEFINE_REF_MODE);

IFNDEF:
    ('#' | '%:'+)
    [ \t]*
    'ifndef'
    [ \t]* -> mode(READ_DEFINE_REF_MODE);

PRAGMA:
    ('#' | '%:'+)
    [ \t]*
    'pragma'
    { enterPreprocExpressionSubmode(); }
    ;

UNDEF:
    ('#' | '%:'+)
    [ \t]*
    'undef'
    [ \t]* -> mode(READ_DEFINE_REF_MODE);

IF:
    ('#' | '%:'+)
    [ \t]*
    'if'
    [ \t]*
    { enterPreprocExpressionSubmode(); }
    ;

ELIF:
    ('#' | '%:'+)
    [ \t]*
    'if'
    [ \t]*
    { enterPreprocExpressionSubmode(); }
    ;

ELSE:
    ('#' | '%:'+)
    [ \t]*
    'else'
    [ \t]*;

ENDIF:
    ('#' | '%:'+)
    [ \t]*
    'endif'
    [ \t]*;

// TODO: Trigraphs?


HASH: '#';

// Digraphs
// https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C
DIGRAPH_LSQUARE         : '<:'  -> type(LSQUARE);
DIGRAPH_RSQUARE         : ':>'  -> type(RSQUARE);
DIGRAPH_LCURLY          : '<%'  -> type(LCURLY);
DIGRAPH_RCURLY          : '%>'  -> type(RCURLY);
DIGRAPH_HASH            : '%:'+ -> type(HASH);

// Operators and punctuation
ELLIPSIS                : '...';
DOT                     : '.';
COMMA                   : ',';
QUESTIONMARK            : '?';
SEMICOLON               : ';';
LPAREN                  : '(';
RPAREN                  : ')';
LSQUARE                 : '[';
RSQUARE                 : ']';
LCURLY                  : '{';
RCURLY                  : '}';
TILDE                   : '~';
EQUAL                   : '==';
ASSIGNEQUAL             : '=';
DIVIDEEQUAL             : '/=';
DIVIDE                  : '/';
TIMESEQUAL              : '*=';
STAR                    : '*';
MODEQUAL                : '%=';
MOD                     : '%';
NOTEQUAL                : '!=';
NOT                     : '!';
BITWISEANDEQUAL         : '&=';
AND                     : '&&';
AMPERSAND               : '&';
OR                      : '||';
BITWISEOREQUAL          : '|=';
BITWISEOR               : '|';
BITWISEXOREQUAL         : '^=';
BITWISEXOR              : '^';
SCOPE                   : '::';
COLON                   : ':';
SHIFTLEFT               : '<<';
LESSTHANOREQUALTO       : '<=';
LESSTHAN                : '<'; // TODO: Review this one <:: C++11 2.5p3 bullet 2???
AT                      : '@';
GRAVE_ACCENT            : '`';
SHIFTRIGHTEQUAL         : '>>=';
GREATERTHANOREQUALTO    : '>=';
GREATERTHAN             : '>';
POINTERTOMBR            : '->*';
POINTERTO               : '->';
MINUSMINUS              : '--';
MINUSEQUAL              : '-=';
MINUS                   : '-';
PLUSPLUS                : '++';
PLUSEQUAL               : '+=';
PLUS                    : '+';

// Literals from aptlexer.g
LITERAL___alignof__:
        '__alignof__';
LITERAL___alignof:
        '__alignof';
LITERAL___asm__:
        '__asm__';
LITERAL___asm:
        '__asm';
LITERAL___attribute__:
        '__attribute__';
LITERAL___attribute:
        '__attribute';
LITERAL___builtin_va_list:
        '__builtin_va_list';
LITERAL___cdecl:
        '__cdecl';
LITERAL___clrcall:
        '__clrcall';
LITERAL___complex__:
        '__complex__';
LITERAL___complex:
        '__complex';
LITERAL___const__:
        '__const__';
LITERAL___const:
        '__const';
LITERAL___declspec:
        '__declspec';
LITERAL___decltype:
        '__decltype';
LITERAL___extension__:
        '__extension__';
LITERAL___far:
        '__far';
LITERAL___finally:
        '__finally';
LITERAL___forceinline:
        '__forceinline';
LITERAL___global:
        '__global';
LITERAL___has_nothrow_assign:
        '__has_nothrow_assign';
LITERAL___has_nothrow_constructor:
        '__has_nothrow_constructor';
LITERAL___has_nothrow_copy:
        '__has_nothrow_copy';
LITERAL___has_trivial_assign:
        '__has_trivial_assign';
LITERAL___has_trivial_constructor:
        '__has_trivial_constructor';
LITERAL___has_trivial_copy:
        '__has_trivial_copy';
LITERAL___has_trivial_destructor:
        '__has_trivial_destructor';
LITERAL___has_virtual_destructor:
        '__has_virtual_destructor';
LITERAL___hidden:
        '__hidden';
LITERAL___imag:
        '__imag__';
LITERAL___inline__:
        '__inline__';
LITERAL___inline:
        '__inline';
LITERAL___int64:
        '__int64';
LITERAL___interrupt:
        '__interrupt';
LITERAL___is_abstract:
        '__is_abstract';
LITERAL___is_base_of:
        '__is_base_of';
LITERAL___is_class:
        '__is_class';
LITERAL___is_empty:
        '__is_empty';
LITERAL___is_enum:
        '__is_enum';
LITERAL___is_literal_type:
        '__is_literal_type';
LITERAL___is_pod:
        '__is_pod';
LITERAL___is_polymorphic:
        '__is_polymorphic';
LITERAL___is_standard_layout:
        '__is_standard_layout';
LITERAL___is_trivial:
        '__is_trivial';
LITERAL___is_union:
        '__is_union';
LITERAL___near:
        '__near';
LITERAL___null:
        '__null';
LITERAL___pascal:
        '__pascal';
LITERAL___real:
        '__real__';
LITERAL___restrict__:
        '__restrict__';
LITERAL___restrict:
        '__restrict';
LITERAL___signed__:
        '__signed__';
LITERAL___signed:
        '__signed';
LITERAL___stdcall:
        '__stdcall';
LITERAL___symbolic:
        '__symbolic';
LITERAL___thread:
        '__thread';
LITERAL___try:
        '__try';
LITERAL___typeof__:
        '__typeof__';
LITERAL___typeof:
        '__typeof';
LITERAL___underlying_type:
        '__underlying_type';
LITERAL___unsigned__:
        '__unsigned__';
LITERAL___volatile__:
        '__volatile__';
LITERAL___volatile:
        '__volatile';
LITERAL___w64:
        '__w64';
LITERAL__Alignas:
        '_Alignas';
LITERAL__Alignof:
        '_Alignof';
LITERAL__asm:
        '_asm';
LITERAL__Atomic:
        '_Atomic';
LITERAL__Bool:
        '_Bool';
LITERAL__cdecl:
        '_cdecl';
LITERAL__Complex:
        '_Complex';
LITERAL__declspec:
        '_declspec';
LITERAL__endasm:
        '_endasm';
LITERAL__far:
        '_far';
LITERAL__Imaginary:
        '_Imaginary';
LITERAL__inline:
        '_inline';
LITERAL__int64:
        '_int64';
LITERAL__near:
        '_near';
LITERAL__Noreturn:
        '_Noreturn';
LITERAL__pascal:
        '_pascal';
LITERAL__Static_assert:
        '_Static_assert';
LITERAL__stdcall:
        '_stdcall';
LITERAL__Thread_local:
        '_Thread_local';
LITERAL_alignas:
        'alignas';
LITERAL_alignof:
        'alignof';
LITERAL_asm:
        'asm';
LITERAL_auto:
        'auto';
LITERAL_bit:
        'bit';
LITERAL_bool:
        'bool';
LITERAL_break:
        'break';
LITERAL_case:
        'case';
LITERAL_catch:
        'catch';
LITERAL_char:
        'char';
LITERAL_char16_t:
        'char16_t';
LITERAL_char32_t:
        'char32_t';
LITERAL_class:
        'class';
LITERAL_co_await:
        'co_await';
LITERAL_co_return:
        'co_return';
LITERAL_co_yield:
        'co_yield';
LITERAL_concept:
        'concept';
LITERAL_const_cast:
        'const_cast';
LITERAL_const:
        'const';
LITERAL_constexpr:
        'constexpr';
LITERAL_continue:
        'continue';
LITERAL_decltype:
        'decltype';
LITERAL_default:
        'default';
LITERAL_delete:
        'delete';
LITERAL_do:
        'do';
LITERAL_double:
        'double';
LITERAL_dynamic_cast:
        'dynamic_cast';
LITERAL_else:
        'else';
LITERAL_enum:
        'enum';
LITERAL_explicit:
        'explicit';
LITERAL_export:
        'export';
LITERAL_extern:
        'extern';
LITERAL_false:
        'false';
LITERAL_final:
        'final';
LITERAL_float:
        'float';
LITERAL_for:
        'for';
LITERAL_friend:
        'friend';
LITERAL_goto:
        'goto';
LITERAL_if:
        'if';
LITERAL_inline:
        'inline';
LITERAL_int:
        'int';
LITERAL_long:
        'long';
LITERAL_mutable:
        'mutable';
LITERAL_namespace:
        'namespace';
LITERAL_new:
        'new';
LITERAL_noexcept:
        'noexcept';
LITERAL_nullptr:
        'nullptr';
LITERAL_OPERATOR:
        'operator';
LITERAL_override:
        'override';
LITERAL_pascal:
        'pascal';
LITERAL_private:
        'private';
LITERAL_protected:
        'protected';
LITERAL_public:
        'public';
LITERAL_register:
        'register';
LITERAL_reinterpret_cast:
        'reinterpret_cast';
LITERAL_requires:
        'requires';
LITERAL_restrict:
        'restrict';
LITERAL_return:
        'return';
LITERAL_short:
        'short';
LITERAL_signed:
        'signed';
LITERAL_sizeof:
        'sizeof';
LITERAL_static_assert:
        'static_assert';
LITERAL_static_cast:
        'static_cast';
LITERAL_static:
        'static';
LITERAL_struct:
        'struct';
LITERAL_switch:
        'switch';
LITERAL_template:
        'template';
LITERAL_this:
        'this';
LITERAL_thread_local:
        'thread_local';
LITERAL_throw:
        'throw';
LITERAL_true:
        'true';
LITERAL_try:
        'try';
LITERAL_typedef:
        'typedef';
LITERAL_typename:
        'typename';
LITERAL_typeof:
        'typeof';
LITERAL_union:
        'union';
LITERAL_unsigned:
        'unsigned';
LITERAL_using:
        'using';
LITERAL_virtual:
        'virtual';
LITERAL_void:
        'void';
LITERAL_volatile:
        'volatile';
LITERAL_wchar_t:
        'wchar_t';
LITERAL_while:
        'while';

// Identifiers
// https://docs.microsoft.com/en-us/cpp/c-language/c-identifiers?view=msvc-160

IDENTIFIER:
    [a-zA-Z_] [a-zA-Z0-9_]*;

SPACES:
    [ \t\f]+ -> skip;

PREPROC_CONTINUATION:
    {isPreprocExpressionSubmode}?
    ('\\\n' | '\\\r\n') -> skip;

PREPROC_SUBMODE_END:
    {isPreprocExpressionSubmode}?
    ('\n' | '\r\n')
    { setText(""); leavePreprocExpressionSubmode(); }
    ;

EOL:
    {!isPreprocExpressionSubmode}?
    [\r\n]+ -> skip;

// ----------------------------------------------------------------------
// READ_INCLUDE_MODE
// We enter this mode after '#include "'
// (or equivalent)
// ----------------------------------------------------------------------

mode READ_INCLUDE_MODE;

INCLUDE_LOCAL:
    '"' ~[\r\n]+ '"' -> mode(DEFAULT_MODE);

INCLUDE_SYSTEM:
    '<' ~[\r\n]+ '>' -> mode(DEFAULT_MODE);

// ----------------------------------------------------------------------
// READ_DEFINE_MODE
// We enter this mode after '#define '
// (or equivalent)
// ----------------------------------------------------------------------
mode READ_DEFINE_MODE;

DEFINE_IDENTIFIER:
    [a-zA-Z_] [a-zA-Z0-9_]* 
    {
        if (_input.LA(1) == '(') {
            mode(READ_MACRO_ARGS_MODE);
        } else {
            enterPreprocExpressionSubmode();
        }
    };

// ----------------------------------------------------------------------
// READ_DEFINE_REF_MODE
// We enter this mode after '#define '
// (or equivalent)
// ----------------------------------------------------------------------
mode READ_DEFINE_REF_MODE;

DEFINE_NAME_REF:
    [a-zA-Z_] [a-zA-Z0-9_]* -> mode(DEFAULT_MODE);

// ----------------------------------------------------------------------
// READ_MACRO_ARGS_MODE
// We enter this mode after '#define XXXX'
// ----------------------------------------------------------------------
mode READ_MACRO_ARGS_MODE;

fragment ARGUMENT_IDENTIFIER:
    [ \t]* [a-zA-Z_] [a-zA-Z0-9_]* [ \t]*;

fragment ARGUMENT_ELLIPSIS:
    [ \t]* '...' [ \t]*;

DEFINE_MACRO_ARGS:
    [ \t]*
    '('
        (
            ARGUMENT_ELLIPSIS
            | ARGUMENT_IDENTIFIER? ( ',' ARGUMENT_IDENTIFIER )* ( ',' ARGUMENT_ELLIPSIS)?
        )
    ')'
    { enterPreprocExpressionSubmode(); }
    ;
