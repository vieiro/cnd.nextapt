/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * APTLexer is  an  Antlr-4  version of  the  old cnd.apt  
 * "aptlexer.g" written in Antlr 2.
 *
 * References:
 * - Antlr4 Lexer Rules https://github.com/antlr/antlr4/blob/master/doc/lexer-rules.md
 * - Antlr4 Predicates in Lexer Rules: https://github.com/antlr/antlr4/blob/master/doc/predicates.md#predicates-in-lexer-rules
 */

lexer grammar APTLexer;

// Some channels used to send tokens we're not interested in
channels {COMMENT}

options {
    language = Java;
}


@lexer::header {
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/* This file was automatically generated by Antlr4 from APTLexer.g4. */

}

@lexer::members {
    public static enum LanguageMode {
        C_CPP,
        FORTRAN
    };
    private LanguageMode languageMode = LanguageMode.C_CPP;

    /*
     * A flag that indicates that we're reading a preprocessor expression in DEFAULT_MODE.
     * This means that:
     * - A '\' followed that \n or \r\n must be ignored.
     * - A \n or a \r\n must emit PREPROC_SUBMODE_END token.
     */
    protected boolean isPreprocExpressionSubmode = false;

    protected void enterPreprocExpressionSubmode() {
        isPreprocExpressionSubmode = true;
        mode(DEFAULT_MODE);
    }

    protected void leavePreprocExpressionSubmode() {
        isPreprocExpressionSubmode = false;
        mode(DEFAULT_MODE);
    }
}

// ----------------------------------------------------------------------
// DEFAULT_MODE
// This is the mode that the lexer runs by default.
// - In this mode we recognize:
//   - C/C++/Objective-C strings
//   - C/C++ block comments and comments (in C/C++ mode).
//   - Fortran comments (in Fortran mode).
//   - Some punctuation tokens (';', '/', '/=' ,etc.)
//   - C preprocessor directives (using antlr4 'lexical modes').
//   - We do _not_ recognize language specific operators/keywords.
// - Additional posterior lexers/filters are responsible for language
//   specific keyword/operator recognition.
// ----------------------------------------------------------------------

FORTRAN_COMMENT:
    { languageMode == LanguageMode.FORTRAN }?
    '!' ~[\r\n]* -> channel(COMMENT);

FORTRAN_77_COMMENT:
    { languageMode == LanguageMode.FORTRAN && getCharPositionInLine() == 0}?
    [cC*] ~[\r\n]* -> channel(COMMENT);

LINE_COMMENT:
    { languageMode == LanguageMode.C_CPP }?
    '//' ~[\r\n]* -> channel(COMMENT);

BLOCK_COMMENT:
    { languageMode == LanguageMode.C_CPP }?
    '/*' .*? '*/' -> channel(COMMENT);

fragment STRING_ENCODING:
    'u8' | 'u' | 'U' | 'L' | '@';

// See https://docs.microsoft.com/en-us/cpp/c-language/octal-and-hexadecimal-character-specifications?view=msvc-160
fragment OCTAL_DIGIT:
    (
        [0-7]
        | [1-7][0-7]
        | [1-7][0-7][0-7]
    );

fragment HEXADECIMAL_DIGIT:
    (
        [0-9A-Fa-f]
        | [0-9A-Fa-f] [0-9A-Fa-f]
        | [0-9A-Fa-f] [0-9A-Fa-f] [0-9A-Fa-f]
    );

// Characters allowed in a non-raw string
// https://docs.microsoft.com/en-us/cpp/c-language/c-character-constants?view=msvc-160
fragment STRING_CHAR:
    (
        '\\' ('\r\n' | '\n') // Continuation line
        | '\\x' HEXADECIMAL_DIGIT
        | '\\' ['!?abfnrtv\\] // Character escape sequences (\r \a)
        | '\\' OCTAL_DIGIT
        | ~[\n\r"\\]
    );

        
STRING_LITERAL:
    STRING_ENCODING?
    (
        '"' STRING_CHAR* '"'
    );

// Characters

fragment CHAR_ENCODING:
    'u' | 'U' | 'L';

fragment CHAR_CONTENT:
    (
        '\\' ('\r\n' | '\n') // Continuation line
        | '\\x' HEXADECIMAL_DIGIT
        | '\\' ['!?abfnrtv\\] // Character escape sequences (\r \a)
        | '\\' OCTAL_DIGIT
        | ~[\n\r\\]
    );

CHAR_LITERAL:
    CHAR_ENCODING?  '\'' CHAR_CONTENT '\'' ;

// Numbers

fragment DECIMAL:
    [0-9] [0-9]*;

ULONG:
    DECIMAL ('ull' | 'uLL' | 'Ull' | 'ULL' | 'llu' | 'LLu' | 'LLU')?;

LONG:
    DECIMAL ('ul' | 'uL' | 'Ul' | 'UL' | 'lu' | 'lU' | 'Lu' | 'LU')?;

INTEGER:
    DECIMAL;

HEXADECIMAL:
    '0' [xX] [0-9a-fA-F]+;

fragment SIGN:
    [+-];

REAL:
    DECIMAL '.' DECIMAL? ([eE] SIGN? DECIMAL)?;

// #include "... and %:+ include "...
INCLUDE:
    ('#' | '%:'+)
    [ \t]*
    'include'
    [ \t]*
    -> mode(READ_INCLUDE_MODE);

// #define "... and %:+ include "...
DEFINE:
    ('#' | '%:'+)
    [ \t]*
    'define'
    [ \t]* -> mode(READ_DEFINE_MODE);

IFDEF:
    ('#' | '%:'+)
    [ \t]*
    'ifdef'
    [ \t]* -> mode(READ_DEFINE_REF_MODE);

IFNDEF:
    ('#' | '%:'+)
    [ \t]*
    'ifndef'
    [ \t]* -> mode(READ_DEFINE_REF_MODE);

PRAGMA:
    ('#' | '%:'+)
    [ \t]*
    'pragma'
    { enterPreprocExpressionSubmode(); }
    ;

UNDEF:
    ('#' | '%:'+)
    [ \t]*
    'undef'
    [ \t]* -> mode(READ_DEFINE_REF_MODE);

IF:
    ('#' | '%:'+)
    [ \t]*
    'if'
    [ \t]*
    { enterPreprocExpressionSubmode(); }
    ;

ELIF:
    ('#' | '%:'+)
    [ \t]*
    'if'
    [ \t]*
    { enterPreprocExpressionSubmode(); }
    ;

ELSE:
    ('#' | '%:'+)
    [ \t]*
    'else'
    [ \t]*;

ENDIF:
    ('#' | '%:'+)
    [ \t]*
    'endif'
    [ \t]*;

// TODO: Trigraphs?


HASH: '#';

// Digraphs
// https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C
DIGRAPH_LSQUARE         : '<:'  -> type(LSQUARE);
DIGRAPH_RSQUARE         : ':>'  -> type(RSQUARE);
DIGRAPH_LCURLY          : '<%'  -> type(LCURLY);
DIGRAPH_RCURLY          : '%>'  -> type(RCURLY);
DIGRAPH_HASH            : '%:'+ -> type(HASH);

// Operators and punctuation
ELLIPSIS                : '...';
DOT                     : '.';
COMMA                   : ',';
QUESTIONMARK            : '?';
SEMICOLON               : ';';
LPAREN                  : '(';
RPAREN                  : ')';
LSQUARE                 : '[';
RSQUARE                 : ']';
LCURLY                  : '{';
RCURLY                  : '}';
TILDE                   : '~';
EQUAL                   : '==';
ASSIGNEQUAL             : '=';
DIVIDEEQUAL             : '/=';
DIVIDE                  : '/';
TIMESEQUAL              : '*=';
STAR                    : '*';
MODEQUAL                : '%=';
MOD                     : '%';
NOTEQUAL                : '!=';
NOT                     : '!';
BITWISEANDEQUAL         : '&=';
AND                     : '&&';
AMPERSAND               : '&';
OR                      : '||';
BITWISEOREQUAL          : '|=';
BITWISEOR               : '|';
BITWISEXOREQUAL         : '^=';
BITWISEXOR              : '^';
SCOPE                   : '::';
COLON                   : ':';
SHIFTLEFT               : '<<';
LESSTHANOREQUALTO       : '<=';
LESSTHAN                : '<'; // TODO: Review this one <:: C++11 2.5p3 bullet 2???
AT                      : '@';
GRAVE_ACCENT            : '`';
SHIFTRIGHTEQUAL         : '>>=';
GREATERTHANOREQUALTO    : '>=';
GREATERTHAN             : '>';
POINTERTOMBR            : '->*';
POINTERTO               : '->';
MINUSMINUS              : '--';
MINUSEQUAL              : '-=';
MINUS                   : '-';
PLUSPLUS                : '++';
PLUSEQUAL               : '+=';
PLUS                    : '+';

// Identifiers
// https://docs.microsoft.com/en-us/cpp/c-language/c-identifiers?view=msvc-160

IDENTIFIER:
    [a-zA-Z_] [a-zA-Z0-9_]*;

SPACES:
    [ \t\f]+ -> skip;

PREPROC_CONTINUATION:
    {isPreprocExpressionSubmode}?
    ('\\\n' | '\\\r\n') -> skip;

PREPROC_SUBMODE_END:
    {isPreprocExpressionSubmode}?
    ('\n' | '\r\n')
    { setText(""); leavePreprocExpressionSubmode(); }
    ;

EOL:
    {!isPreprocExpressionSubmode}?
    [\r\n]+ -> skip;

// ----------------------------------------------------------------------
// READ_INCLUDE_MODE
// We enter this mode after '#include "'
// (or equivalent)
// ----------------------------------------------------------------------

mode READ_INCLUDE_MODE;

INCLUDE_LOCAL:
    '"' ~[\r\n]+ '"' -> mode(DEFAULT_MODE);

INCLUDE_SYSTEM:
    '<' ~[\r\n]+ '>' -> mode(DEFAULT_MODE);

// ----------------------------------------------------------------------
// READ_DEFINE_MODE
// We enter this mode after '#define '
// (or equivalent)
// ----------------------------------------------------------------------
mode READ_DEFINE_MODE;

DEFINE_IDENTIFIER:
    [a-zA-Z_] [a-zA-Z0-9_]* 
    {
        if (_input.LA(1) == '(') {
            mode(READ_MACRO_ARGS_MODE);
        } else {
            enterPreprocExpressionSubmode();
        }
    };

// ----------------------------------------------------------------------
// READ_DEFINE_REF_MODE
// We enter this mode after '#define '
// (or equivalent)
// ----------------------------------------------------------------------
mode READ_DEFINE_REF_MODE;

DEFINE_NAME_REF:
    [a-zA-Z_] [a-zA-Z0-9_]* -> mode(DEFAULT_MODE);

// ----------------------------------------------------------------------
// READ_MACRO_ARGS_MODE
// We enter this mode after '#define XXXX'
// ----------------------------------------------------------------------
mode READ_MACRO_ARGS_MODE;

fragment ARGUMENT_IDENTIFIER:
    [ \t]* [a-zA-Z_] [a-zA-Z0-9_]* [ \t]*;

fragment ARGUMENT_ELLIPSIS:
    '...';

DEFINE_MACRO_ARGS:
    [ \t]*
    '('
        (
            ARGUMENT_ELLIPSIS
            | ARGUMENT_IDENTIFIER? ( ',' ARGUMENT_IDENTIFIER )* ( ',' ARGUMENT_ELLIPSIS)?
        )
    ')'
    { enterPreprocExpressionSubmode(); }
    ;
